pca <- as.data.frame(pcMatrix)
pca$cluster <- as.character(res$cluster)
if (plot) {
library(ggplot2)
print(ggplot(pca, aes(x=PC1, y=PC2, color=cluster)) + geom_point())}
return(pca)
}
centerDetection <- function(corM=dis_matrix_pearson2, genelist=genelist){
if (length(genelist)==1) {
# print("WARN: only one gene in genelist!")
return(genelist[1])}
corMsub <- corM[genelist, genelist]
corRowSum <- rowSums(corMsub)
return(names(sort(corRowSum)[1]))
}
singleModuleDetection <- function(corM=dis_matrix_pearson2, overlapM=geneOverlap,center=center, topCount=10, corThresd=0.5, overlapThresd=3, centerBlackList=c()){
genelist <- c(center)
while (length(genelist) < topCount) {
centerBlackList=c(centerBlackList, center)
nearestGeneV <- sort(corM[center,!colnames(corM)%in%genelist])[1]
nearestGene <- names(nearestGeneV)
if (nearestGeneV > corThresd) {
# print("nearestGeneV > corThresd")
return(list(genelist=genelist, centerBlackList=unique(centerBlackList)))
} else if (overlapM[center, nearestGene] < overlapThresd) {
# print("overlapM[center, nearestGene] < overlapThresd")
return(list(genelist=genelist, centerBlackList=unique(centerBlackList)))
}
genelist <- c(genelist, nearestGene)
center <- centerDetection(corM, genelist)
# print(paste("nearestGene is: ", nearestGene, ", new center is: ", center, sep=" "))
}
# genelist <- moduleShift(corM, genelist)
# pheatmap(logcounts(tmp_group)[genelist,], show_colnames = F, cluster_rows = F)
return(list(genelist=genelist, centerBlackList=unique(centerBlackList)))
}
moduleShift <- function(corM=dis_matrix_pearson2, genelist=genelist, centerBlackList=c()) {
if (length(genelist)==1) {
return(list(genelist=genelist, centerBlackList=unique(centerBlackList)))
}
while (T){
center <- centerDetection(corM, genelist)
centerBlackList=c(centerBlackList, center)
nearestGene <- names(sort(corM[center,!colnames(corM)%in%genelist])[1])
disSumOutlier <- sort(rowSums(corM[genelist, genelist]), decreasing = T)[1]
genelist1 <- c(genelist, nearestGene)
genelist1 <- genelist1[!genelist1%in%names(disSumOutlier)]
nearestGeneDis <- sum(corM[nearestGene, genelist1])
if (nearestGeneDis < disSumOutlier) {
genelist <- genelist1
# print(paste(nearestGene, "is closer than", names(disSumOutlier), ". replace it already!"))
}
else {
# print("Gene set has local convergence")
break}
}
return(list(genelist=genelist, centerBlackList=unique(centerBlackList)))
}
result <- outlierDetection(M=logcounts(tmp_group))
tmp_group <- tmp_group[,result$cluster!=0]
expr_log3 <- t(logcounts(tmp_group))
expr_log4 <- apply(expr_log3>=1,2,function(x) {storage.mode(x) <- 'integer'; x})
geneOverlap <- t(expr_log4) %*% expr_log4
library(WGCNA)
# standard deviation can't be zero
# cor_matrix_pearson <- WGCNA::cor(x = as.matrix((expr_log3)), method = "pearson")
cor_matrix_spearman <- WGCNA::cor(x = as.matrix((expr_log3)), method = "spearman")
dis_matrix_pearson2 <- 1 - abs(cor_matrix_spearman)
dis_matrix_pearson2[is.na(dis_matrix_pearson2)] <- 1
dis_matrix_pearson2[row(dis_matrix_pearson2)==col(dis_matrix_pearson2)] <- 1
minPerRow <- apply(dis_matrix_pearson2, 2, min)
?quantile
quantile(minPerRow, probs = seq(0, 1, 0.25))
dim(dis_matrix_pearson2)
quantile(minPerRow, probs = seq(0, 1, 0.25))[2]
dim(dis_matrix_pearson2[names(minPerRow[minPerRow < 0.5]),names(minPerRow[minPerRow < 0.5])])
corThresd <- quantile(minPerRow, probs = seq(0, 1, 0.25))[2]
dim(dis_matrix_pearson2[names(minPerRow[minPerRow < corThresd]),names(minPerRow[minPerRow < corThresd])])
dis_matrix_pearson3 <- as.dist(dis_matrix_pearson2)
library(dbscan)
res <- dbscan(dis_matrix_pearson3, eps = 0.5, minPts = 3)
res
dim(dis_matrix_pearson2)
dis_matrix_pearson2 <- dis_matrix_pearson2[names(minPerRow[minPerRow < corThresd]),names(minPerRow[minPerRow < corThresd])]
dim(dis_matrix_pearson2)
res <- dbscan(dis_matrix_pearson3, eps = 0.5, minPts = 3)
dis_matrix_pearson3 <- as.dist(dis_matrix_pearson2)
res <- dbscan(dis_matrix_pearson3, eps = 0.5, minPts = 3)
res
min(dis_matrix_pearson2)
max(dis_matrix_pearson2)
epsLevels <- seq(0, 1, by=0.01)
epsLevels
clusterCount <- c()
alleps <- c()
minPts=5
table(res$cluster)
length(table(res$cluster))
length(table(res$cluster)) - 1
clusterCount <- length(table(res$cluster)) - 1
clusterCount
allClusterCount <- c(allClusterCount, clusterCount)
epsLevels <- seq(0, 1, by=0.01)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
disMatrix=dis_matrix_pearson3
epsLevels <- seq(0, 1, by=0.01)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
allClusterCount <- c(allClusterCount, clusterCount)
}
epsLevels <- seq(0, 1, by=0.1)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
print(paste("eps: ", eps, "gene cluster number: ", clusterCount))
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
start=0.2; end=0.4
epsLevels <- seq(start, end, by=(end-start)/10)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
print(paste("eps: ", eps, ", gene cluster number: ", clusterCount))
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
start=0.32; end=0.36
epsLevels <- seq(start, end, by=(end-start)/10)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
print(paste("eps: ", eps, ", gene cluster number: ", clusterCount))
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
allClusterCount
allClusterCount[which(max(allClusterCount))]
allClusterCount[which(allClusterCount==max(allClusterCount))]
which(allClusterCount==max(allClusterCount))
which(allClusterCount==max(allClusterCount))[1]
which(allClusterCount==max(allClusterCount))[1]-1
which(allClusterCount==max(allClusterCount))
maxStart <- which(allClusterCount==max(allClusterCount))[1]
maxEnd <- which(allClusterCount==max(allClusterCount))[length(which(allClusterCount==max(allClusterCount)))]
maxStart
maxEnd
epsDetectionCor <- function(disMatrix=dis_matrix_pearson3, start=0, end=1, minPts=5, plot=F){
# DBSCAN
library(dbscan)
# if (primary==T){ by = 1 } else {by=(end-start)/100}
epsLevels <- seq(start, end, by=(end-start)/10)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
print(paste("eps: ", eps, ", gene cluster number: ", clusterCount))
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
maxStart <- which(allClusterCount==max(allClusterCount))[1]
maxEnd <- which(allClusterCount==max(allClusterCount))[length(which(allClusterCount==max(allClusterCount)))]
return(names(allClusterCount[maxStart-1]), names(allClusterCount[maxStart+1]))
# allClusterCount <- allClusterCount[!is.na(allClusterCount)]
# allClusterCount <- allClusterCount[allClusterCount!=dim(disMatrix)[1]]
# if (plot) {plot(allnoiseCount)}
# if (primary==T)
# {return(c(as.integer(names(allnoiseCount)[1]), as.integer(names(allnoiseCount)[length(allnoiseCount)])))}
# else {return(as.double(names(sort(allnoiseCount[allnoiseCount>=percent*dim(disMatrix)[1]])[1])))}
# {return(as.double(names(sort(allnoiseCount %% as.integer(percent*dim(pcMatrix)[1]))[1])))}
}
epsDetectionCor()
epsDetectionCor <- function(disMatrix=dis_matrix_pearson3, start=0, end=1, minPts=5, plot=F){
# DBSCAN
library(dbscan)
# if (primary==T){ by = 1 } else {by=(end-start)/100}
epsLevels <- seq(start, end, by=(end-start)/10)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
print(paste("eps: ", eps, ", gene cluster number: ", clusterCount))
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
maxStart <- which(allClusterCount==max(allClusterCount))[1]
maxEnd <- which(allClusterCount==max(allClusterCount))[length(which(allClusterCount==max(allClusterCount)))]
return(c(names(allClusterCount[maxStart-1]), names(allClusterCount[maxStart+1])))
# allClusterCount <- allClusterCount[!is.na(allClusterCount)]
# allClusterCount <- allClusterCount[allClusterCount!=dim(disMatrix)[1]]
# if (plot) {plot(allnoiseCount)}
# if (primary==T)
# {return(c(as.integer(names(allnoiseCount)[1]), as.integer(names(allnoiseCount)[length(allnoiseCount)])))}
# else {return(as.double(names(sort(allnoiseCount[allnoiseCount>=percent*dim(disMatrix)[1]])[1])))}
# {return(as.double(names(sort(allnoiseCount %% as.integer(percent*dim(pcMatrix)[1]))[1])))}
}
epsDetectionCor()
epsDetectionCor <- function(disMatrix=dis_matrix_pearson3, start=0, end=1, minPts=5, plot=F){
# DBSCAN
library(dbscan)
# if (primary==T){ by = 1 } else {by=(end-start)/100}
epsLevels <- seq(start, end, by=(end-start)/10)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
print(paste("eps: ", eps, ", gene cluster number: ", clusterCount))
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
maxStart <- which(allClusterCount==max(allClusterCount))[1]
maxEnd <- which(allClusterCount==max(allClusterCount))[length(which(allClusterCount==max(allClusterCount)))]
return(c(as.double(names(allClusterCount[maxStart-1])), as.double(names(allClusterCount[maxStart+1]))))
# allClusterCount <- allClusterCount[!is.na(allClusterCount)]
# allClusterCount <- allClusterCount[allClusterCount!=dim(disMatrix)[1]]
# if (plot) {plot(allnoiseCount)}
# if (primary==T)
# {return(c(as.integer(names(allnoiseCount)[1]), as.integer(names(allnoiseCount)[length(allnoiseCount)])))}
# else {return(as.double(names(sort(allnoiseCount[allnoiseCount>=percent*dim(disMatrix)[1]])[1])))}
# {return(as.double(names(sort(allnoiseCount %% as.integer(percent*dim(pcMatrix)[1]))[1])))}
}
epsDetectionCor()
epsDetectionCor(start = 0.2, end = 0.4)
eps <- 0
while (T) {
start <- 0
end <- 1
epsPair <- epsDetectionCor(dis_matrix_pearson3, start=start, end=end)
if (length(epsPair)!=1){
start <-  epsPair[1]
end <-  epsPair[2]
} else if (length(epsPair)==1){
eps <- epsPair
break
}
}
eps <- 0
start <- 0
end <- 1
while (T) {
epsPair <- epsDetectionCor(dis_matrix_pearson3, start=start, end=end)
if (length(epsPair)==2){
start <-  epsPair[1]
end <-  epsPair[2]
} else if (length(epsPair)==1){
eps <- epsPair
break
}
}
epsDetectionCor <- function(disMatrix=dis_matrix_pearson3, start=0, end=1, minPts=5, plot=F){
# DBSCAN
library(dbscan)
# if (primary==T){ by = 1 } else {by=(end-start)/100}
epsLevels <- seq(start, end, by=(end-start)/10)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
print(paste("eps: ", eps, ", gene cluster number: ", clusterCount))
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
maxStart <- which(allClusterCount==max(allClusterCount))[1]
maxEnd <- which(allClusterCount==max(allClusterCount))[length(which(allClusterCount==max(allClusterCount)))]
if (allClusterCount[maxStart]==allClusterCount[maxEnd]) {return(as.double(names(allClusterCount[maxStart])))}
return(c(as.double(names(allClusterCount[maxStart-1])), as.double(names(allClusterCount[maxStart+1]))))
# allClusterCount <- allClusterCount[!is.na(allClusterCount)]
# allClusterCount <- allClusterCount[allClusterCount!=dim(disMatrix)[1]]
# if (plot) {plot(allnoiseCount)}
# if (primary==T)
# {return(c(as.integer(names(allnoiseCount)[1]), as.integer(names(allnoiseCount)[length(allnoiseCount)])))}
# else {return(as.double(names(sort(allnoiseCount[allnoiseCount>=percent*dim(disMatrix)[1]])[1])))}
# {return(as.double(names(sort(allnoiseCount %% as.integer(percent*dim(pcMatrix)[1]))[1])))}
}
epsDetectionCor(start = 0.32, end = 0.36)
eps <- 0
start <- 0
end <- 1
while (T) {
epsPair <- epsDetectionCor(dis_matrix_pearson3, start=start, end=end)
if (length(epsPair)==2){
start <-  epsPair[1]
end <-  epsPair[2]
} else if (length(epsPair)==1){
eps <- epsPair
break
}
}
eps
epsDetectionCor <- function(disMatrix=dis_matrix_pearson3, start=0, end=1, minPts=5, plot=F){
# DBSCAN
library(dbscan)
# if (primary==T){ by = 1 } else {by=(end-start)/100}
epsLevels <- seq(start, end, by=(end-start)/10)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
print(paste("eps: ", eps, ", gene cluster number: ", clusterCount))
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
maxStart <- which(allClusterCount==max(allClusterCount))[1]
maxEnd <- which(allClusterCount==max(allClusterCount))[length(which(allClusterCount==max(allClusterCount)))]
if (length(which(allClusterCount==max(allClusterCount)))>1) {return(as.double(names(allClusterCount[maxStart])))}
return(c(as.double(names(allClusterCount[maxStart-1])), as.double(names(allClusterCount[maxStart+1]))))
# allClusterCount <- allClusterCount[!is.na(allClusterCount)]
# allClusterCount <- allClusterCount[allClusterCount!=dim(disMatrix)[1]]
# if (plot) {plot(allnoiseCount)}
# if (primary==T)
# {return(c(as.integer(names(allnoiseCount)[1]), as.integer(names(allnoiseCount)[length(allnoiseCount)])))}
# else {return(as.double(names(sort(allnoiseCount[allnoiseCount>=percent*dim(disMatrix)[1]])[1])))}
# {return(as.double(names(sort(allnoiseCount %% as.integer(percent*dim(pcMatrix)[1]))[1])))}
}
epsDetectionCor(start = 0.32, end = 0.36)
eps <- 0
start <- 0
end <- 1
count <- 0
while (T) {
count <- count + 1
print(paste("Round:", count))
epsPair <- epsDetectionCor(dis_matrix_pearson3, start=start, end=end)
if (length(epsPair)==2){
start <-  epsPair[1]
end <-  epsPair[2]
} else if (length(epsPair)==1){
eps <- epsPair
break
}
}
eps
epsDetectionCor <- function(disMatrix=dis_matrix_pearson3, start=0, end=1, step=10, minPts=5, plot=F){
# DBSCAN
library(dbscan)
# if (primary==T){ by = 1 } else {by=(end-start)/100}
epsLevels <- seq(start, end, by=(end-start)/step)
allClusterCount <- c()
alleps <- c()
for ( eps in epsLevels){
#eps <- 5*(i-1)
alleps <- c(alleps, eps)
# minPts <- 10
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
clusterCount <- length(table(res$cluster)) - 1
print(paste("eps: ", eps, ", gene cluster number: ", clusterCount))
allClusterCount <- c(allClusterCount, clusterCount)
}
names(allClusterCount) <- alleps
maxStart <- which(allClusterCount==max(allClusterCount))[1]
maxEnd <- which(allClusterCount==max(allClusterCount))[length(which(allClusterCount==max(allClusterCount)))]
if (length(which(allClusterCount==max(allClusterCount)))>1) {return(as.double(names(allClusterCount[maxStart])))}
return(c(as.double(names(allClusterCount[maxStart-1])), as.double(names(allClusterCount[maxStart+1]))))
# allClusterCount <- allClusterCount[!is.na(allClusterCount)]
# allClusterCount <- allClusterCount[allClusterCount!=dim(disMatrix)[1]]
# if (plot) {plot(allnoiseCount)}
# if (primary==T)
# {return(c(as.integer(names(allnoiseCount)[1]), as.integer(names(allnoiseCount)[length(allnoiseCount)])))}
# else {return(as.double(names(sort(allnoiseCount[allnoiseCount>=percent*dim(disMatrix)[1]])[1])))}
# {return(as.double(names(sort(allnoiseCount %% as.integer(percent*dim(pcMatrix)[1]))[1])))}
}
eps <- 0
start <- 0
end <- 1
count <- 0
while (T) {
count <- count + 1
print(paste("Round:", count))
epsPair <- epsDetectionCor(dis_matrix_pearson3, start=start, end=end)
if (length(epsPair)==2){
start <-  epsPair[1]
end <-  epsPair[2]
} else if (length(epsPair)==1){
eps <- epsPair
break
}
}
eps
minPts <- 5
res <- dbscan(disMatrix, eps = eps, minPts = minPts)
res
res$cluster
marker_result <- data.frame(gene=rownames(disMatrix),cluster=res$cluster,row.names = rownames(disMatrix))
rownames(disMatrix)
marker_result <- data.frame(gene=rownames(dis_matrix_pearson2),cluster=res$cluster,row.names = rownames(dis_matrix_pearson2))
marker_result
marker_result[marker_result$cluster!=0,]
marker_result <- marker_result[marker_result$cluster!=0,]
marker_result$cluster <- as.integer(as.factor(marker_result$cluster))
marker_result
table(marker_result)
marker_result
table(marker_result$cluster)
moduleResult <- list()
count <- 1
count2 <- 0
j <- 0
totalCount <- dim(corM)[1]
centerBlackList <- c()
# for (i in 1:length(table(marker_result$cluster))) {
for (center in rownames(corM)) {
# geneCluster <- marker_result[marker_result$cluster==i,]$gene
# center <- centerDetection(corM, geneCluster)
count2 <- count2 + 1
if (count2%%as.integer(totalCount/10)==0){
j <- j+1
print(paste(j*10, "percent was finished..."))}
# center <- i
# print(center)
result1 <- singleModuleDetection(corM=corM, overlapM=geneOverlap, center=center, centerBlackList=centerBlackList, topCount=100)
genelist <- result1[["genelist"]]
centerBlackList1 <- result1[["centerBlackList"]]
result2 <- moduleShift(corM, genelist, centerBlackList=centerBlackList1)
genelist <- result2[["genelist"]]
centerBlackList2 <- result2[["centerBlackList"]]
tempCenter <- centerDetection(corM, genelist)
if (tempCenter%in%centerBlackList) {
# print(paste(tempCenter, "is duplicated center!", sep=" "))
next}
centerBlackList <- c(centerBlackList, centerBlackList2)
# print(genelist)
if (length(genelist) >= 5){
moduleResult[[count]] <- genelist
count <- count + 1
}
}
corM=dis_matrix_pearson2
moduleResult <- list()
count <- 1
count2 <- 0
j <- 0
totalCount <- dim(corM)[1]
centerBlackList <- c()
# for (i in 1:length(table(marker_result$cluster))) {
for (center in rownames(corM)) {
# geneCluster <- marker_result[marker_result$cluster==i,]$gene
# center <- centerDetection(corM, geneCluster)
count2 <- count2 + 1
if (count2%%as.integer(totalCount/10)==0){
j <- j+1
print(paste(j*10, "percent was finished..."))}
# center <- i
# print(center)
result1 <- singleModuleDetection(corM=corM, overlapM=geneOverlap, center=center, centerBlackList=centerBlackList, topCount=100)
genelist <- result1[["genelist"]]
centerBlackList1 <- result1[["centerBlackList"]]
result2 <- moduleShift(corM, genelist, centerBlackList=centerBlackList1)
genelist <- result2[["genelist"]]
centerBlackList2 <- result2[["centerBlackList"]]
tempCenter <- centerDetection(corM, genelist)
if (tempCenter%in%centerBlackList) {
# print(paste(tempCenter, "is duplicated center!", sep=" "))
next}
centerBlackList <- c(centerBlackList, centerBlackList2)
# print(genelist)
if (length(genelist) >= 5){
moduleResult[[count]] <- genelist
count <- count + 1
}
}
marker_result
